#!/usr/bin/env python
#
# Copyright 2011 Joseph Rawlings
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
##########################################################################
import webapp2
import os
import jinja2
import hmac
import string
import re
import random
import hashlib
import json
import logging
import time

from google.appengine.api import memcache
from google.appengine.ext import db

template_dir = os.path.join(os.path.dirname(__file__), 'templates/unit7')
jinja_env = jinja2.Environment(loader = jinja2.FileSystemLoader(template_dir), autoescape = False)
jinja_env_escaped = jinja2.Environment(loader = jinja2.FileSystemLoader(template_dir), autoescape = True)

# Cache DB entries using MemCache.
#
# 1) A key must be specified, the function will return
#    the requested wiki page if it exists
#
# Everything will be cached
def load_page(title, version = None, update = False):

	key = title if not version else title + ',' + version

	result = memcache.get(key)

	if update or not result:
		cursor = None
		if not version:
			# log text indicating the app is querying the database
			logging.error("Query Wiki Page '%s'" % key[0])
			# select the latest wiki page version
			cursor = db.GqlQuery("SELECT * FROM Page WHERE title = :1 ORDER BY version DESC", title, limit = 1)
		else:
			# log text indicating the app is querying the database
			logging.error("Query Wiki Page '%s' with specific version '%s'" % (title, version))
			# select a specific wiki page version
			cursor = db.GqlQuery("SELECT * FROM Page WHERE title = :1 AND version = :2", title, int(version), limit = 1)
		# run query once, grab the results, and cache them
		if cursor.count() > 0:
			memcache.set(key, (cursor[0], int(round(time.time()))))
	# return the wiki page
	return memcache.get(key)

# Secret value used in the HMAC
SECRET = 'mysecret'

# Generates a random salt value using letters only
def make_salt(size=5, chars=string.letters):
    return ''.join(random.choice(chars) for x in range(size))

# Generates a HASH over a name, password, and salt
#
# If no salt is provided, one is generated
def make_pw_hash(name, pw, salt = None):
	if not salt:
		salt = make_salt()
	return '%s|%s' % (hashlib.sha256(name + pw + salt).hexdigest(), salt)

# Validates a password based on the output from a
# HASH generated by 'make_pw_hash'
def valid_pw(name, pw, h):
	salt = h.split('|')[1]
	return h == make_pw_hash(name, pw, salt)

# Generates a HMAC HASH using a string and SECRET
def hash_str(s):
    return hmac.new(SECRET, s).hexdigest()

# Generates a 'secure value' based on the 'hash_str' function
def make_secure_val(s):
	return "%s|%s" % (s, hash_str(s))

# Checks the validity of the 'secure value' based on the
# output of a previously generated 'secure value'
def check_secure_val(h):
	val = h.split('|')[0]
	return val if h == make_secure_val(val) else None

# RegEx for the username field
USERNAME_RE = re.compile(r"^[a-zA-Z0-9_-]{3,20}$")
# RegEx for the password field
PASSWORD_RE = re.compile(r"^.{3,20}$")
# RegEx for the Email field
EMAIL_RE = re.compile(r"^[\S]+@[\S]+\.[\S]+$")

# Validation for Usernames
def valid_username(username):
	return USERNAME_RE.match(username)

# Validation for Passwords
def valid_password(password):
	return PASSWORD_RE.match(password)

# Validation for Emails
def valid_email(email):
	return EMAIL_RE.match(email)

# Generic webapp Handler with some helper functions
class Handler(webapp2.RequestHandler):
	def write(self, *a, **kw):
		self.response.out.write(*a, **kw)

	def render_str(self, template, **params):
		t = jinja_env.get_template(template)
		return t.render(params)

	def render_str_escaped(self, template, **params):
		t = jinja_env_escaped.get_template(template)
		return t.render(params)

	def render(self, template, **kw):
		self.write(self.render_str(template, **kw))

	def render_content(self, template, **kw):
		content = self.render_str(template, **kw)
		self.render("index.html", content=content, user=self.get_logged_in_user(), **kw)

	# helper method to see if a User is logged in or not
	def is_logged_in(self):
		user_id = None
		user = None
		user_id_str = self.request.cookies.get('user_id')
		if user_id_str:
			user_id = check_secure_val(user_id_str)
		return user_id

	# helper method that returns the actual logged in User
	def get_logged_in_user(self):
		user_id = self.is_logged_in()
		user = None
		if user_id:
			user = User.get_by_id(long(user_id))
		return user

# Model object representing a Wiki Page
class Page(db.Model):
	content = db.TextProperty(required = True)
	title = db.StringProperty(required = True, indexed=True)
	version = db.IntegerProperty(required = True, indexed=True)
	created = db.DateTimeProperty(auto_now_add = True)

# Model object representing a User of the Wiki
class User(db.Model):
	username = db.StringProperty(required = True)
	password_hash = db.StringProperty(required = True)
	email = db.StringProperty(required = False)
	created = db.DateTimeProperty(auto_now_add = True)

# Handler for logging out of the Wiki
#
# Also clears out the user_id cookie
class Unit7LogoutHandler(Handler):
	def get(self):
		self.response.headers.add_header('Set-Cookie', 'user_id=; Path=/')
		self.redirect("/unit7")

# Handler for logging in to the Wiki
#
# 1) Check against the DB to see if the User exists
# 2) Validate the User's password against the stored Hash/Salt
# 3) Set the user_id login cookie 
# 4) Redirect the User to the Welcome page
#
# If the login attempt fails, reset the user_id cookie and show the login page again
class Unit7LoginHandler(Handler):
	def get(self):
		self.render_content("login.html")

	def post(self):
		username = self.request.get('username')
		password = self.request.get('password')

		users = db.GqlQuery("SELECT * FROM User WHERE username = :1", username, limit=1)

		if users.count() == 1 and valid_pw(users[0].username, password, users[0].password_hash):
			self.response.headers.add_header('Set-Cookie', 'user_id=%s; Path=/' % make_secure_val(str(users[0].key().id())))
			self.redirect("/unit7")
		else:
			self.response.headers.add_header('Set-Cookie', 'user_id=; Path=/')
			login_error="Invalid login"
			self.render_content("login.html", error=login_error)

# Handler for new user signups
class Unit7SingupHandler(Handler):
	def get(self):
		self.render_content("signup.html")

	# When signing up a new user, the username, password
	# and verify fields are required. The email is optional. 
	# If there are any field values in error, a message
	# will be displayed indicating so, otherwise, the User
	# is created and redirected to the main page '/'
	def post(self):
		username = self.request.get('username')
		password = self.request.get('password')
		verify = self.request.get('verify')
		email = self.request.get('email')

		username_error = ""
		password_error = ""
		verify_error = ""
		email_error = ""

		if not valid_username(username):
			username_error = "That's not a valid username."
		if not (db.GqlQuery("SELECT * FROM User WHERE username = :1", username, limit=1)).count() != 1:
			username_error = "That username already exists."
		if not valid_password(password):
			password_error = "That wasn't a valid password."
		if not password == verify:
			verify_error = "Your passwords didn't match."
		if email and not valid_email(email):
			email_error = "That's not a valid email"

		if not (username_error == "" and password_error == "" and verify_error == "" and not (email and email_error)):
			self.render_content("signup.html"
				, username=username
				, username_error=username_error
				, password_error=password_error
				, verify_error=verify_error
				, email=email
				, email_error=email_error)
		else:
			user = User(username=username, password_hash=make_pw_hash(username, password), email=email)
			user.put()
			self.response.headers.add_header('Set-Cookie', 'user_id=%s; Path=/' % make_secure_val(str(user.key().id())))
			self.redirect("/unit7")

# Handler for a specific Wiki Page Entry
class Unit7WikiPageHandler(Handler):
	def get(self, title, args):
		
		if title == None:
			title = '/'

		# get the version query param if available
		version = self.request.get('v')

		# retrieve the Page from the Database
		page = load_page(title, version)

		if not page:
			self.redirect("/unit7/_edit%s" % title)
		else:
			# calculate seconds since last cache miss
			seconds = int(round(time.time())) - page[1]
			# render straight html using templates
			self.render_content("page.html", page=page[0], seconds=seconds)

# Handler for posting new Wiki Page Entries
class Unit7EditWikiPageHandler(Handler):
	def render_edit_page(self, title, content=""):
		if self.is_logged_in():
			page = load_page(title)
			self.render_content("edit_page.html", page=page[0] if page else None)
		else:
			self.redirect("/unit7/login")

	def get(self, title, args):
		if self.is_logged_in():
			self.render_edit_page(title = title)
		else:
			self.redirect("/unit7/login")

	# When submitting new wiki page entries, the content 
	# field is required. If the wiki page is valid, persist 
	# the entry to the DB and redirect to the permalink.
	def post(self, title, args):
		if self.is_logged_in():
			content = self.request.get("content")

			page = load_page(title)

			if page:
				page = Page(title=title, content=content, version=page[0].version+1)
			else:
				page = Page(title=title, content=content, version=0)

			page.put()
			load_page(title, update = True)
			self.redirect("/unit7%s" % title)
		else:
			self.redirect("/unit7/login")

# Handler for the History page 
#
# This handler simply displays the history of a Wiki Page
# while providing the ability to edit and view a particular 
# page version
class Unit7HistoryWikiPageHandler(Handler):
	def get(self, title, args):
		if title == None:
			title = '/'

		# retrieve the Page Versions from the Database
		pageVersions = db.GqlQuery("SELECT * FROM Page WHERE title = :1", title)
		# display all of the different versions
		self.render_content("history.html", versions=list(pageVersions))

# regular expression for handling arbitrary page names
PAGE_RE = r'((/(?:[a-zA-Z0-9_-]+/?)*))?'
# All WebApp Handlers
app = webapp2.WSGIApplication([
		# handler for editing wiki pages
		('/unit7/_edit' + PAGE_RE, Unit7EditWikiPageHandler)
		# handler for showing the history of wiki pages
		, ('/unit7/_history' + PAGE_RE, Unit7HistoryWikiPageHandler)
		# handler for logging in
		, ('/unit7/login', Unit7LoginHandler)
		# handler for logging out
		, ('/unit7/logout', Unit7LogoutHandler)
		# handler for signing users up
		, ('/unit7/signup', Unit7SingupHandler)
		# handler for showing wiki pages
		, ('/unit7' + PAGE_RE, Unit7WikiPageHandler)
	], debug=True)