import webapp2
import os
import jinja2
import hmac
import string
import re
import random
import hashlib
import json
import logging
import time

from google.appengine.api import memcache
from google.appengine.ext import db

template_dir = os.path.join(os.path.dirname(__file__), 'templates/unit6')
jinja_env = jinja2.Environment(loader = jinja2.FileSystemLoader(template_dir), autoescape = False)
jinja_env_escaped = jinja2.Environment(loader = jinja2.FileSystemLoader(template_dir), autoescape = True)

# Cache DB entries using MemCache.
#
# 1) If no key is specified, the function will return
#    all of the posts (used for the main page)
# 2) If a key is specified, it will be assumed that
#    this is an ID of an Entry in the DB
#
# Everything will be cached until the /flush URL is hit
def load_post(key = 'top', update = False):

	result = memcache.get(key)

	if update or (key == 'top' and not result):
		# log text indicating the app is querying the database
		logging.error("Query All Blog Entries")
		# select all of our blog entries
		cursor = db.GqlQuery("SELECT * FROM Entry ORDER BY created DESC")
		# run query once, grab the results, and cache them
		memcache.set(key, (list(cursor), int(round(time.time()))))
	elif not result:
		# select all of our blog entries
		result = Entry.get_by_id(long(key))
		# run query once, grab the results, and cache them
		memcache.set(key, (result, int(round(time.time()))))
	# return all of the posts
	return memcache.get(key)

# Secret value used in the HMAC
SECRET = 'mysecret'

# Generates a random salt value using letters only
def make_salt(size=5, chars=string.letters):
    return ''.join(random.choice(chars) for x in range(size))

# Generates a HASH over a name, password, and salt
#
# If no salt is provided, one is generated
def make_pw_hash(name, pw, salt = None):
	if not salt:
		salt = make_salt()
	return '%s|%s' % (hashlib.sha256(name + pw + salt).hexdigest(), salt)

# Validates a password based on the output from a
# HASH generated by 'make_pw_hash'
def valid_pw(name, pw, h):
	salt = h.split('|')[1]
	return h == make_pw_hash(name, pw, salt)

# Generates a HMAC HASH using a string and SECRET
def hash_str(s):
    return hmac.new(SECRET, s).hexdigest()

# Generates a 'secure value' based on the 'hash_str' function
def make_secure_val(s):
	return "%s|%s" % (s, hash_str(s))

# Checks the validity of the 'secure value' based on the
# output of a previously generated 'secure value'
def check_secure_val(h):
	val = h.split('|')[0]
	return val if h == make_secure_val(val) else None

# RegEx for the username field
USERNAME_RE = re.compile(r"^[a-zA-Z0-9_-]{3,20}$")
# RegEx for the password field
PASSWORD_RE = re.compile(r"^.{3,20}$")
# RegEx for the Email field
EMAIL_RE = re.compile(r"^[\S]+@[\S]+\.[\S]+$")

# Validation for Usernames
def valid_username(username):
	return USERNAME_RE.match(username)

# Validation for Passwords
def valid_password(password):
	return PASSWORD_RE.match(password)

# Validation for Emails
def valid_email(email):
	return EMAIL_RE.match(email)

# Generic webapp Handler with some helper functions
class Handler(webapp2.RequestHandler):
	def write(self, *a, **kw):
		self.response.out.write(*a, **kw)

	def render_str(self, template, **params):
		t = jinja_env.get_template(template)
		return t.render(params)

	def render_str_escaped(self, template, **params):
		t = jinja_env_escaped.get_template(template)
		return t.render(params)

	def render(self, template, **kw):
		self.write(self.render_str(template, **kw))

	def render_content(self, template, **kw):
		content = self.render_str_escaped(template, **kw)
		self.render("index.html", content=content)

	def render_json(self, content):
		# set the content type as JSON
		self.response.headers['Content-Type'] = 'application/json'
		# write out content as JSON and handle date objects with the default handler for now
		self.response.out.write(json.dumps(content, default= lambda obj: obj.isoformat()))

# Model object representing a Blog Entry
class Entry(db.Model):
	content = db.TextProperty(required = True)
	subject = db.StringProperty(required = True)
	created = db.DateTimeProperty(auto_now_add = True)

# Model object representing a User of the Blog
class User(db.Model):
	username = db.StringProperty(required = True)
	password_hash = db.StringProperty(required = True)
	email = db.StringProperty(required = False)
	created = db.DateTimeProperty(auto_now_add = True)

# Handler for the main page of the Blog
# 
# Will check for /.json routing and render
# the appropriate content type
class Unit6Handler(Handler):
	def render_posts(self, args):
		
		posts = load_post()

		if args == '/.json':
			# map the _entity which contains the raw model attributes
			self.render_json(content=[e._entity for e in posts[0]])
		else:
			# calculate seconds since last cache miss
			seconds = int(round(time.time())) - posts[1]
			# render straight html using templates
			self.render_content("post.html", entries=posts[0], seconds=seconds)

	def get(self, args):
		self.render_posts(args)

# Handler for flushing the cache
# 
# Will clear all of the caches and redirect to 
# the default home screen
class Unit6FlushHandler(Handler):
	def get(self):
		memcache.flush_all()
		self.redirect("/unit6")

# Handler for a specific Blog Entry
# 
# Will check for .json routing and render
# the appropriate content type
class Unit6EntryHandler(Handler):
	def get(self, entry_id, args):
		# retrieve the Entry from the Database
		entry = load_post(entry_id)
		if args == '.json':
			# use the _entity which contains the raw model attributes
			self.render_json(content=entry[0]._entity)
		else:
			# calculate seconds since last cache miss
			seconds = int(round(time.time())) - entry[1]
			# render straight html using templates
			self.render_content("post.html", entries=[entry[0]], seconds=seconds)

# Handler for logging out of the Blog
#
# Also clears out the user_id cookie
class Unit6LogoutHandler(Handler):
	def get(self):
		self.response.headers.add_header('Set-Cookie', 'user_id=; Path=/')
		self.redirect("/unit6/signup")

# Handler for logging in to the Blog
#
# 1) Check against the DB to see if the User exists
# 2) Validate the User's password against the stored Hash/Salt
# 3) Set the user_id login cookie 
# 4) Redirect the User to the Welcome page
#
# If the login attempt fails, reset the user_id cookie and show the login page again
class Unit6LoginHandler(Handler):
	def get(self):
		self.render_content("login.html")

	def post(self):
		username = self.request.get('username')
		password = self.request.get('password')

		users = db.GqlQuery("SELECT * FROM User WHERE username = :1", username, limit=1)

		if users.count() == 1 and valid_pw(users[0].username, password, users[0].password_hash):
			self.response.headers.add_header('Set-Cookie', 'user_id=%s; Path=/' % make_secure_val(str(users[0].key().id())))
			self.redirect("/unit6/welcome")
		else:
			self.response.headers.add_header('Set-Cookie', 'user_id=; Path=/')
			login_error="Invalid login"
			self.render_content("login.html", error=login_error)

# Handler for new user signups
class Unit6SingupHandler(Handler):
	def get(self):
		self.render_content("signup.html")

	# When submitting new blog entries, the subject and content 
	# fields are required. If the blog entry is valid, persist 
	# the entry to the DB and redirect to the the permalink. If
	# there is an issue, display an error
	def post(self):
		username = self.request.get('username')
		password = self.request.get('password')
		verify = self.request.get('verify')
		email = self.request.get('email')

		username_error = ""
		password_error = ""
		verify_error = ""
		email_error = ""

		if not valid_username(username):
			username_error = "That's not a valid username."
		if not valid_password(password):
			password_error = "That wasn't a valid password."
		if not password == verify:
			verify_error = "Your passwords didn't match."
		if email and not valid_email(email):
			email_error = "That's not a valid email"

		if not (username_error == "" and password_error == "" and verify_error == "" and not (email and email_error)):
			self.render_content("signup.html"
				, username=username
				, username_error=username_error
				, password_error=password_error
				, verify_error=verify_error
				, email=email
				, email_error=email_error)
		else:
			user = User(username=username, password_hash=make_pw_hash(username, password), email=email)
			user.put()
			self.response.headers.add_header('Set-Cookie', 'user_id=%s; Path=/' % make_secure_val(str(user.key().id())))
			self.redirect("/unit6/welcome")

# Handler for the Welcome screen 
#
# This handler simply displays the User's username on a Welcome
# screen by looking at the user_id cookie
class Unit6WelcomeHandler(Handler):
	def get(self):
		user_id = 0
		user = None
		user_id_str = self.request.cookies.get('user_id')
		if user_id_str:
			user_id = check_secure_val(user_id_str)

		if not user_id:
			self.redirect("/unit6/signup")
		else:
			user = User.get_by_id(long(user_id))
			self.render_content("welcome.html", user=user)

# Handler for posting new Blog Entries
class Unit6NewPostHandler(Handler):

	def render_new_post(self, subject="", content="", error=""):
		self.render_content("new_post.html", subject=subject, content=content, error=error)

	def get(self):
		self.render_new_post()

	# When submitting new blog entries, the subject and content 
	# fields are required. If the blog entry is valid, persist 
	# the entry to the DB and redirect to the the permalink. If
	# there is an issue, display an error
	def post(self):
		subject = self.request.get("subject")
		content = self.request.get("content")

		if subject and content:
			entry = Entry(subject = subject, content = content)
			entry.put()
			load_post(update = True)
			self.redirect("/unit6/" + str(entry.key().id()))
		else:
			error = "subject and content, please!"
			self.render_new_post(subject=subject, content=content, error = error)

# All WebApp Handlers
app = webapp2.WSGIApplication([
		# render HTML or JSON depending on the suffix provided
		  ('/unit6(/.json)?', Unit6Handler)
		# handler for submitting new posts
		, ('/unit6/newpost', Unit6NewPostHandler)
		# handler for logging in
		, ('/unit6/login', Unit6LoginHandler)
		# handler for logging out
		, ('/unit6/logout', Unit6LogoutHandler)
		# handler for signing users up
		, ('/unit6/signup', Unit6SingupHandler)
		# welcome handler
		, ('/unit6/welcome', Unit6WelcomeHandler)
		# flush the cache and redirect
		, ('/unit6/flush', Unit6FlushHandler)
		# render HTML or JSON depending on the suffix provided
		, ('/unit6/(\d+)(.json)?', Unit6EntryHandler)
	], debug=True)